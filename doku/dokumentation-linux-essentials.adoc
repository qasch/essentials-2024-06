= Dokumentation Linux Essentials
:toc:

== Hilfe auf der Kommandozeile

* Option `<kommanod> --help`
* Manpages `man <kommando>`: gibt es in der Regel nur für _extern_ realisierte Kommandos, nicht für _Builtins_ (z.B. `cd`, `export`, `alias` usw.)
* `help <builtin>` zeigt die Hifle Seite für Builtins (in die Shell eingebaute Kommandos) an
* `help` Liste aller Builtins
* `type <kommanod>` zeigt die Art eines Kommandos an: extern, Builtin, Alias etc.
* Zusatzinfo: Info System: `info <kommando>` zeigt die Info-Seite eines Kommandos an. Info Seiten sind noch ausführlicher als die Manpages, gibt es aber nicht für alle Kommandos, muss mit `apt install info` installiert werden

== Autocompletion

Mit der TAB-Taste können Pfade, Kommandos, Optionen usw. automatisch vervollständigt werden. Gibt es mehrere Möglichkeiten zur Vervollständigung, kann man zweimal die TAB-Taste drücken und erhält eine Übersicht über die verschiedenen Möglichkeiten.

== Sonderzeichen und Escaping

* In der BASH gibt es bestimmte Sonderzeichen, welche nicht als reguläre Satzzeichen interpretiert werden, sonder eine Sonderbedeutung haben.
* Eins der wichtigsten Sonderzeichen ist das Leerzeichen/Space, dies ist das *Trennzeichen*, hiermit erkennt die Shell z.B. was eine Kommando ist, was eine Option, was ein Argument usw.
* Wollen wir ein Sonderzeichen als reguläres Satzzeichen darstellen ohne Sonderbedeutung, so müssen wir dieses Zeichen _maskieren_ bzw. _escapen_:
* die doppelten Anführungszeichen `"` escapen alle Sonderzeichen bis auf das `$` (Substitution)
* die einfachen Sonderzeichen `'` escapen sämtliche Sonderzeichen
* der Backslash `\` maskiert das direkt darauffolgende Zeichen
* einige Sonderzeichen: 
** `<kommanod1> ; <kommando2>`: beide Kommandos werden nacheinander ausgeführt, unabhängig, ob sie erfolgreich waren oder nicht 
** `<kommando1> && <kommando2>`: `<kommando2>` wird nur dann ausgeführt, wenn `<kommando1>` *erfolgreich ausgeführt* werden konnte
** `<kommando1> || <kommando2>`: `<kommando2>` wird nur dann ausgeführt, wenn `<kommando1>` *nicht erfolgreich ausgeführt* werden konnte
** `~`: Abkürzung für das Heimatverzeichnis des aktuellen Benutzers
** `$`: Substitution/Ersetzung, z.B.: `$var` `$(kommando)` `$(( berechnung ))`
** `#`: Leitet einen Kommentar ein
** `*`: Globbing Character (Asterisk) - steht für ein beliebiges Zeichen, dass beliebig oft vorkommen darf (auch kein Mal)
** `?`: Globbing Character - steht für ein beliebiges Zeichen, dass exakt einaml vorkommt

== Subshells

Eine Shell, die innerhalb einer anderen Shell geöffnet wird. Passiert relativ oft, ohne dass wir es direkt merken, z.B. bei der Kommandosubstitution, beim Aufruf von Funktionen in Skripten usw. Eine Subshell ist abhängig von der Elternshell. Wird die Elternshell geschlossen, werden gleichzeitig auch alle Subshells geschlossen.

== Variablen

* es gibt zwei Arten von Variablen: 
** *Shellvariablen*: sind nur in der aktuellen Shell gültig
** *Umgebungsvariablen*: sind in allen Shells gültig (werden komplett in Großbuchstaben geschrieben [Konvention]), müssen in bestimmten Dateien konfiguriert werden (z.B. `~/.bashrc`, `~/.profile` etc.)
* mit dem Kommado `export` kann eine Shellvariable auch in Subshells verfügbar gemacht werden

== Arithmetische Operationen / Rechnen in der Shell

* Möchte man in der Shell (mit Variablen) rechnen, kann dies auf zwei Weisen erfolgen:

----
$(( ausdruck ))

summe = $(( zahl1 + zahl2))
----

oder:

----
let summe = zahl1 + zahl2
----

Hilfe dazu findet sich in der Manpage der BASH (Suche z.B. nach _arithmetic_ in der englischen Version)

== History

Jedes Kommando wird in der History der Shell gespeichert. Bei der BASH ist es z.B. die Datei `~/.bash_history`. Mit dem Kommando `history` kann eine Liste dieser Kommandos angezeigt werden. Jedes Kommando hat einen Index `<index>`. 

Ein bestimmtes Kommando kann folgendermaßen erneut aufgerufen werden:

 !<index>

Ansonsten können mit den Cursor (Pfeil nach oben) oder mittels STRG+P die zuletzt eingegebenen Kommandos aufgerufen werden.

Andere nützliche History-Shortcuts:

* `!!` das komplette zuletzt eingegebene Kommando (z.B. `sudo !!` um das letzte Kommando erneut mit Root-Rechten auszuführen)
* `!?` das letzte Argument des zuletzt ausgeführten Kommandos:

----
ls -l /some/folder/somewhere/in/path
chown -R tux:tux !$
----

== Brace Expansion

* `touch file_{001..100}.txt` erstellt 100 Dateien mit den Namen `file_001.txt` bis `file_100.txt`
* `ls *.{txt,pdf}` zeigt alle `txt` und `pdf` Dateien an

== Konfigurationsdateien

* Systemweite Konfigurationsdateien: liegen immer unter `/etc`, sind für alle Benutzer gültig (z.B. `/etc/bash.bashrc`)
* Benutzerspezifische Konfigurationsdateien: liegen immer im Heimatverzeichnis des Benutzers, beginnen immer mit einem Punkt (`.`) oder liegen in einem Verzeichnis, das mit einem Punkt beginnt (z.B. `~/.bashrc`, `~/.config/htop`)
* Einträge in den benutzerspezifischen Konfigurationsdateien überschreiben ggf. Einträge aus der systemweiten
* So können Bentzer selbst gewisse Einstellungen vorhnehmen ohne Root-Rechte haben zu müssen, z.B. Aliase erstellen, die BASH konfigurieren...

== Textströme 

== UNIX-Philosophie

1. Schreibe Programme so, dass sie *eine* Aufgabe erledigen, und diese gut machen
2. Schreibe Programme so, dass sie zusammenarbeiten
3. Schreibe Programme so, dass sie Textströme verarbeiten, denn Text ist eine universelle Schnittstelle

== Standardkanäle 

- Standardeingabekanal - `stdin` - Kanalnr. 0
- Standardausgabekanal - `stdout` - Kanalnr. 1
- Standardfehlerkanal - `stderr` - Kanalnr. 2

== Redirect

Mit einem Redirect kann ein Datenstrom in eine *Datei* umgeleitet werden.

- `>` Mit einem _einfachen_ Redirect wird der Standardausgabekanal oder der Standardfehlerkanal in eine Datei umgeleitet. Die Datei muss vorher nicht existiert haben, sie wird ggf. erzeugt. Eine bereits bestehende Datei wird zuerst geleert/der Inhalt gelöscht und anschließend mit dem Inhalt des Datenstroms beschrieben.

 ls /etc 1> ausgabe_ls.txt     # stdout(1) in datei
 ls /etc > ausgabe_ls.txt     # stdout(1) in datei

 ls /gibtsnicht 2> fehler_ls.txt     # stderr(2) in datei

- `>>` Mit einem _doppelten_ (anhängenden) Redirect wird der Inhalt des Datenstroms (`stdout` oder `stderr`) an eine bereits bestehende Datei angehängt. Eine nicht existierende Datei würde erzeugt werden.
- `&>` So werden sowohl `stdout` als auch `stderr` in eine Datei umgeleitet

 ls /etc /gibtsnicht &> ausgabe_und_fehler.txt

`sterr` wird in `stdout` umgeleteitet und dann `stdout` in datei
das `&1` ist nötig, damit der Shell klar ist, dass der Kanal 1 gemeint ist
ansonsten würde die Datei `1` erstellt werden

 ls /etc /gibtsnicht > ausgabe_und_fehler.txt 2>&1    

- `<` Mit dem umgedrehten Redirect kann der Inhalt einer Datei an den Eingabekanal eines Kommandos geleitet werden

 mail -s Mail_Subject empfaenger@mail.example < mailinhalt.txt

== Pipe

Mit der Pipe `|` wird der Ausgabekanal eines Kommandos an den Eingabekanal eines weiteren Kommandos umgeleitet.

- `<Kommando1> | <kommando2>`

 ls -l /etc | less
 grep alias ~/.bashrc | grep -v `#`

== Filterkommandos

Wir nutzen Filterkommandos um aus einem Textstrom den Inhalt zu herauszufiltern, den wir haben wollen 

=== grep

Alle Zeilen anzeigen, die das Pattern `alias` enthalten. Es wird immer die gesamte Zeile ausgegeben in der das Pattern vorkommt.

 grep 'alias' ~/.bashrc

Gesamten Inhalt der Datei `~/.bashrc` anzeigen, Kommentarzeilen *nicht* mit ausgeben

 grep -v `#` ~/.bashrc 

- `grep -i <pattern>`: Gross- und Kleinschreibung von `<pattern>` ist egal
- `grep -n <pattern>`: Anzeige der Zeilennummer, in der `<pattern>` gefunden wurde
- `grep -r <pattern> dir/`: Rekursive Suche, so kann über alle Dateien in einem Verzeichnis _gegrept_ werden
- `grep -v <pattern>`: _inVert match_: Ausgabe wird _invertiert_, also nur die Zeilen ausgegeben, in denen `<pattern>` *nicht* vorkommt
- `grep -c <pattern>`: gibt nicht die Zeilen aus, sondern nur die Anzahl der Zeilen in denen `<pattern>` vorkommt

=== cut

Mit `cut` können wir Spalten/Felder/_Fields_ aus tabellarisch aufgebauten Dateien _ausschneiden_ bzw. filtern. Die wichtigen Optionen für `cut` sind `-d` zur Angabe des Trennzeichens (_Delimiter_) und `-f` zur Angabe der Spalte (_Field_). Bsp.:

Ausschließlich die Login-Namen anzeigen lassen:

 cut -d: -f1 /etc/passwd

=== weitere Filterkommandos

- `tr`: übersetzt ein Zeichen in einem Textstrom (es können keine Dateien als Argument übergeben werden) in ein anderes/löscht dieses etc... 

 tr a A < datei.txt  # wandelt jedes kleine a in ein grosses A um

- `wc`: gibt die Anzahl der Zeilen, Wörter und Bytes einer Datei an 

 wc -l /etc/passwd`  # Anzahl Zeilen der Datei /etc/passwd


